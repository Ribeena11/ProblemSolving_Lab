# -*- coding: utf-8 -*-
"""MusicPlaylist.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12cTpsgVW-_swczCsK98cjBySitr5s4bT
"""

class Song:
    def __init__(self, title, artist, songfile):
        self.title = title
        self.artist = artist
        self.songfile = songfile
        self.next_song = None

    def __str__(self): # ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        return f"{self.title} by {self.artist}"

class MusicPlaylist:
    def __init__(self):
        self.head = None  # The head of the linked list (first song) **‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥ ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•**
        self.current_song = None # To keep track of the currently playing song
        self.length = 0 # How many song in play list

    def add_song(self, title, artist, songfile): # ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ô‡∏ò‡πå‡∏Å‡∏±‡∏ö class Song ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ
        new_song = Song(title, artist, songfile)
        if self.head is None: # ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏´‡∏ô‡∏î‡πÅ‡∏£‡∏Å
            self.head = new_song
            self.current_song = new_song # If first song, it's also the current one
        else:
            current = self.head
            while current.next_song:
                current = current.next_song
            current.next_song = new_song
        self.length += 1
        print(f"Added: {new_song}")

    def add_file(self, filename):
        try :
            with open(filename, "r", encoding = "utf-8") as file:
                for line in file:
                    line = line.strip()
                    if not line:
                        continue

                    title, artist, songfile = line.split(",",2)
                    self.add_song(title.strip(), artist.strip(), songfile.strip())

            print(f"\nSongs loaded from file: {filename}")
        except FileNotFoundError:
            print(f"File '{filename}' not found.")
        except ValueError:
            print("File format error. Each line must be: title, artist, songfile")



    def display_playlist(self):
        if self.head is None:
            print("Playlist is empty.")
            return

        current = self.head
        print("\n--- Your Music Playlist ---")
        count = 1
        while current:
            print(f"{count}. {current}")
            current = current.next_song
            count += 1
        print("---------------------------")

    def play_current_song(self):
        if self.current_song:
            print(f"\nNow playing: {self.current_song}")
        else:
            print("Playlist is empty or no song is selected to play.")

    def next_song(self):
        if self.current_song and self.current_song.next_song:
            self.current_song = self.current_song.next_song
            self.play_current_song()
        elif self.current_song and not self.current_song.next_song:
            print("End of playlist. No next song.")
        else:
            print("Playlist is empty.")

    def prev_song(self):
        if self.head is None or self.current_song is None:
            print("Playlist is empty or no song is selected.")
            return
        if self.current_song == self.head: # ‡∏Å‡∏î prev ‡πÅ‡∏•‡πâ‡∏ß‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö head ‡∏û‡∏≠‡∏î‡∏µ
            print("Already at the beginning of the playlist.")
            return

        current = self.head
        while current.next_song != self.current_song:
            current = current.next_song
        self.current_song = current
        self.play_current_song()

    def get_length(self):
        return self.length

    def delete_song(self, title):
        if self.head is None:
            print(f"Cannot delete '{title}'. Playlist is empty.")
            return

        # If the song to be deleted is the head
        if self.head.title == title:
            if self.current_song == self.head:
                self.current_song = self.head.next_song
            self.head = self.head.next_song
            self.length -= 1
            print(f"Deleted: {title}")
            if self.length == 0:
                self.current_song = None
            return

        current = self.head
        prev = None
        while current and current.title != title:
            prev = current
            current = current.next_song

        if current:
            if self.current_song == current:
                # If the deleted song was the current song, try to set the next song as current
                # If no next, then previous. If no previous, then current becomes None.
                if current.next_song:
                    self.current_song = current.next_song
                elif prev:
                    self.current_song = prev
                else:
                    self.current_song = None # Only one song, and it was deleted

            prev.next_song = current.next_song
            self.length -= 1
            print(f"Deleted: {title}")
        else:
            print(f"Song '{title}' not found in the playlist.")

# """#‡∏™‡∏£‡πâ‡∏≤‡∏á Web App

# 1. installing **streamlit** and **pyngrok** libraries
# """

# pip install streamlit pyngrok

# """2. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå .py"""

# Commented out IPython magic to ensure Python compatibility.
%%writefile app.py
import streamlit as st

# ---------- Song Class ----------
class Song:
    def __init__(self, title, artist, songfile):
        self.title = title
        self.artist = artist
        self.songfile = songfile  # bytes
        self.next_song = None

    def __str__(self):
        return f"{self.title} by {self.artist}"


# ---------- MusicPlaylist Class ----------
class MusicPlaylist:
    def __init__(self):
        self.head = None
        self.current_song = None
        self.length = 0

    def add_song(self, title, artist, songfile):
        new_song = Song(title, artist, songfile)

        if self.head is None:
            self.head = new_song
            self.current_song = new_song
        else:
            current = self.head
            while current.next_song:
                current = current.next_song
            current.next_song = new_song

        self.length += 1
        st.success(f"Added: {new_song}")

    def display_playlist(self):
        songs = []
        current = self.head
        i = 1
        while current:
            songs.append(f"{i}. {current}")
            current = current.next_song
            i += 1
        return songs

    def play_current_song(self):
        if self.current_song:
            st.info(f"Now playing: {self.current_song}")
            st.audio(self.current_song.songfile)
        else:
            st.warning("Playlist is empty or no song selected.")

    def next_song(self):
        if self.current_song and self.current_song.next_song:
            self.current_song = self.current_song.next_song
        else:
            st.warning("End of playlist.")

    def prev_song(self):
        if self.current_song == self.head or self.head is None:
            st.warning("Already at first song.")
            return

        current = self.head
        while current.next_song != self.current_song:
            current = current.next_song
        self.current_song = current

    def delete_song(self, title):
        if self.head is None:
            st.error("Playlist is empty.")
            return

        if self.head.title == title:
            self.head = self.head.next_song
            self.current_song = self.head
            self.length -= 1
            st.success(f"Deleted: {title}")
            return

        prev = self.head
        current = self.head.next_song

        while current:
            if current.title == title:
                prev.next_song = current.next_song
                if self.current_song == current:
                    self.current_song = prev
                self.length -= 1
                st.success(f"Deleted: {title}")
                return
            prev = current
            current = current.next_song

        st.error("Song not found.")

    def get_length(self):
        return self.length


# ---------- Streamlit UI ----------
st.title("·Øì‚ÄéùÑû Music Playlist App")

if "playlist" not in st.session_state:
    st.session_state.playlist = MusicPlaylist()

# ---------- Sidebar: Add Song ----------
st.sidebar.header("‚úö Add Song")
title = st.sidebar.text_input("Title")
artist = st.sidebar.text_input("Artist")
audio_file = st.sidebar.file_uploader(
    "Upload Audio File",
    type=["mp3", "wav", "ogg"]
)

if st.sidebar.button("Add Song to Playlist"):
    if title and artist and audio_file:
        st.session_state.playlist.add_song(
            title,
            artist,
            audio_file.read()
        )
    else:
        st.sidebar.warning("Please enter title, artist, and audio file.")

# ---------- Sidebar: Delete Song ----------
st.sidebar.markdown("---")
st.sidebar.header("üóë Delete Song")
delete_title = st.sidebar.text_input("Song Title to Delete")

if st.sidebar.button("Delete Song"):
    st.session_state.playlist.delete_song(delete_title)

# ---------- Playlist Display ----------
st.header("Your Current Playlist")
playlist = st.session_state.playlist.display_playlist()

if playlist:
    for song in playlist:
        st.write(song)
else:
    st.write("Playlist is empty.")

# ---------- Playback Controls ----------
st.markdown("---")
st.header("Playback Controls")

col1, col2, col3 = st.columns(3)

with col1:
    if st.button("‚èÆ Previous"):
        st.session_state.playlist.prev_song()
        st.session_state.playlist.play_current_song()

with col2:
    if st.button("‚ñ∂ Play"):
        st.session_state.playlist.play_current_song()

with col3:
    if st.button("‚è≠ Next"):
        st.session_state.playlist.next_song()
        st.session_state.playlist.play_current_song()

st.markdown("---")
st.write(f"Total songs: {st.session_state.playlist.get_length()}")

# """3. Login **ngrok** ‡∏ó‡∏µ‡πà https://ngrok.com/ and copy your **authtoken**"""

# !ngrok authtoken 36Jqwz9fewSSAB9dfyTkQARdAUX_51pnjAAmvVPEcc4pa5P9N

# from pyngrok import ngrok

# ngrok.kill()  # ‡∏õ‡∏¥‡∏î tunnel ‡πÄ‡∏Å‡πà‡∏≤

# public_url = ngrok.connect(8501)
# print("üåç Open your app here:", public_url)

# """4. **‡∏£‡∏±‡∏ô app Streamlit** ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤
# ‡∏Å‡∏≤‡∏£‡∏ö‡∏≠‡∏Å‡πÉ‡∏´‡πâ Colab ‡∏£‡∏±‡∏ô‡πÑ‡∏ü‡∏•‡πå calculator.py ‡∏î‡πâ‡∏ß‡∏¢ Streamlit ‡∏ö‡∏ô‡∏û‡∏≠‡∏£‡πå‡∏ï 8501
# """

# !streamlit run app.py --server.port 8501 &